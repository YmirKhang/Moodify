package moodify.service

import java.net.URI

import com.wrapper.spotify.SpotifyApi
import com.wrapper.spotify.model_objects.specification.PlayHistory
import moodify.Config
import moodify.model.{TrackFeatures, Trendline}

/**
  * Communicates with Spotify API.
  */
class SpotifyService extends Config {

  /**
    * Spotify API wrapper instance.
    */
  private val spotifyApi = new SpotifyApi.Builder()
    .setClientId(SPOTIFY_CLIENT_ID)
    .setClientSecret(SPOTIFY_CLIENT_SECRET)
    .setRedirectUri(new URI(SPOTIFY_REDIRECT_URI))
    .build

  /**
    * Authenticate user with given code.
    *
    * @param userId Moodify user id.
    * @param code   The code generated by Spotify for user's authentication.
    * @return Success.
    */
  def authenticate(userId: String, code: String): Boolean = {
    val redisAccessTokenKey = s"user:$userId:token:access"
    val redisRefreshTokenKey = s"user:$userId:token:refresh"

    try {
      // Check if access token exists.
      val maybeAccessToken = RedisService.get(redisAccessTokenKey)
      if (maybeAccessToken.isDefined) {
        val accessToken = maybeAccessToken.get
        spotifyApi.setAccessToken(accessToken)
      }
      // Access token does not exist. Check if refresh token exists.
      else {
        val maybeRefreshToken = RedisService.get(redisRefreshTokenKey)
        if (maybeRefreshToken.isDefined) {
          val refreshToken = maybeRefreshToken.get
          spotifyApi.setRefreshToken(refreshToken)
        }

        // Get new credentials from Spotify.
        val credentials = spotifyApi.authorizationCode(code).build.execute
        val accessToken = credentials.getAccessToken
        val refreshToken = credentials.getRefreshToken
        val accessTokenTTL = credentials.getExpiresIn
        val refreshTokenTTL = 30 * 24 * 60 * 60 // 30 days.

        // Update access token and refresh token.
        spotifyApi.setAccessToken(accessToken)
        spotifyApi.setRefreshToken(refreshToken)
        RedisService.set(redisAccessTokenKey, accessToken, accessTokenTTL)
        RedisService.set(redisRefreshTokenKey, refreshToken, refreshTokenTTL)
      }

      true
    }
    catch {
      case exception: Exception =>
        println(exception.getMessage)
        false
    }
  }

  /**
    * Get recent tracks of current user.
    *
    * @param limit Maximum number of tracks to return.
    * @return Recent tracks.
    */
  def getRecentTracks(limit: Int): Array[PlayHistory] = {
    val recentTracks = spotifyApi.getCurrentUsersRecentlyPlayedTracks
      .limit(limit)
      .build
      .execute
      .getItems

    recentTracks
  }

  /**
    * Get audio features for given track id list.
    *
    * @param trackIdList Track id list.
    * @return Audio features.
    */
  def getAudioFeatures(trackIdList: List[String]): List[TrackFeatures] = {

    // Number of tracks for a single request is limited by Spotify API.
    val requestLimit = 100

    // Fetch audio features from Redis, if available.
    val redisTrendlineList = trackIdList.flatMap { trackId =>
      val redisKey = s"track:$trackId:audio"
      val maybeAudioFeatures = RedisService.hgetall(redisKey)
      if (maybeAudioFeatures.isDefined) {
        val audioFeatures = maybeAudioFeatures.get
        val trendline = Trendline(
          audioFeatures("Acousticness").toDouble,
          audioFeatures("Instrumentalness").toDouble,
          audioFeatures("Speechiness").toDouble,
          audioFeatures("Danceability").toDouble,
          audioFeatures("Liveness").toDouble,
          audioFeatures("Energy").toDouble,
          audioFeatures("Valence").toDouble
        )
        List(TrackFeatures(trackId, trendline))
      }
      // Audio features for current track is not available in Redis.
      else List()
    }

    // Separate tracks with no audio feature data.
    val redisTrackIdList = redisTrendlineList.map(track => track.trackId)
    val newTrackIdList = trackIdList.diff(redisTrackIdList)
    val trackIdListGroups = newTrackIdList.grouped(requestLimit)

    // Get those tracks' audio features from Spotify.
    val spotifyAudioFeatures = trackIdListGroups.flatMap { idList =>
      val commaSeparatedIdList = idList.mkString(",")
      spotifyApi.getAudioFeaturesForSeveralTracks()
        .ids(commaSeparatedIdList)
        .build.execute
    }.toList

    val spotifyTrendlineList = spotifyAudioFeatures.map { audioFeatures =>
      val trackId = audioFeatures.getId
      val trendline = Trendline(
        audioFeatures.getAcousticness.toDouble,
        audioFeatures.getInstrumentalness.toDouble,
        audioFeatures.getSpeechiness.toDouble,
        audioFeatures.getDanceability.toDouble,
        audioFeatures.getLiveness.toDouble,
        audioFeatures.getEnergy.toDouble,
        audioFeatures.getValence.toDouble
      )

      TrackFeatures(trackId, trendline)
    }

    // TODO: Save to Redis.

    redisTrendlineList ++ spotifyTrendlineList
  }

}
